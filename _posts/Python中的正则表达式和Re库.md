---
title: Python中的正则表达式和Re库
mathjax: false
date: 2020-03-08 16:05:51
updated: 2020-03-08 16:05:51
tags: [Python]
categories: [编程语言基础]
toc: true
---

## 1. 正则表达式的概念

正则表达式：**r**egular **e**xpression，regex，RE。

正则表达式是用来简洁表达一组字符串的表达式。

如有一组字符串如下：

```python
'PN'
'PYN'
'PYTM'
'PTRHN'
'PYTHON'
```

这组字符串可以用正则表达式简洁的表示：`'P(Y|YT|YTH|YTHO)?N'`

再有一组字符串如下：

```python
'PY'
'PYY'
'PYYY'
...
'PYYYY...'
```

这组字符串可以用正则表达式简洁的表示：`'PY+'`，`'+'`表示Y可以有1个或无穷多个。

<!--more-->

总得来说，正则表达式具有以下特点：<br/>1. 通用的字符串表达框架。<br/>2. 简洁表达一组字符串的表达式。<br/>3. 针对字符串表达”简洁“和”特征“思想的工具。<br/>4. 判断某字符串的特征归属。

正则表达式在文本处理中十分常用，他可以：<br/>1. 表达文本类型的特征（病毒、入侵等）。<br/>2. 同时查找或替换一组字符串。<br/>3. 匹配字符串的全部或部分。

正则表达式的使用：<br/>编译：将符合正则表达式语法的字符串转换成正则表达式特征。如`p=re.compile(regex)`。<br/>



## 2. 正则表达式的语法

正则表达式语法由字符和操作符构成。

正则表达式的常用操作符有下面这些：

| 操作符              | 说明                                              | 实例                                                         |
| ------------------- | ------------------------------------------------- | ------------------------------------------------------------ |
| `.`                 | 表示任何单个字符，默认不包括换行符。              |                                                              |
| `[]`                | 字符集，对单个字符给出取值范围。                  | `[abc]`表示a、b、c，<br/>`[a-z]`表示a到z的单个字符。         |
| `[^ ]`              | 非字符集，对单个字符给出排除范围。                | `[^abc]`表示非a非b非c的单个字符。                            |
| `*`                 | 前一个字符0次或无限次扩展。                       | `abc*`表示ab、abc、abcc等。                                  |
| `+`                 | 前一个字符1次或无限次扩展。                       | `abc+`表示abc、abcc、abccc等。                               |
| `?`                 | 前一个字符0次或1次扩展。                          | `ab?`表示ab、abc。                                           |
| <code>&#124;</code> | 左右表达式任意一个。                              | <code>abc&#124;def</code>表示abc、def。                      |
| `{m}`               | 扩展前一个字符m次。                               | `ab{2}c`表示abbc。                                           |
| `{m,n}`             | 扩展前一个字符m至n次（含n）。                     | `ab{1,2}c`表示abc、abbc。                                    |
| `^`                 | 匹配字符串开头。                                  | `^abc`表示以abc开头的字符串。                                |
| `$`                 | 匹配字符串结尾。                                  | `abc$`表示以abc结尾的字符串。                                |
| `()`                | 分组标记，内部只能使用<code>&#124;</code>操作符。 | `(abc)`表示abc，<br/><code>(abc&#124;def)</code>表示abc、def。 |
| `\d`                | 数字，等价于`[0-9]`。                             |                                                              |
| `\w`                | 单词字符，等价于`[A-Za-z0-9]`。                   |                                                              |

经典正则表达式实例：

| 实例                                      | 说明                           |
| ----------------------------------------- | ------------------------------ |
| `^[A-Za-z]+$`                             | 由26个字母组成的字符串。       |
| `^[A-Za-z0-9]+$`                          | 由26个字母和数字组成的字符串。 |
| `^-?\d+$`                                 | 整数形式的字符串。             |
| `^[0-9]*[1-9][0-9]*$`                     | 正整数形式的字符串。           |
| `[1-9]\d{5}`                              | 中国境内邮政编码，6位。        |
| `[\u4e00-\u9fa5]`                         | 匹配中文字符。                 |
| <code>\d{3}-\d{8}&#124;\d{4}-\d{7}</code> | 国内电话号码，010-68913536。   |



我们练习一下，如何写一个匹配IP地址的正则表达式。

IP地址分4段，每段0-255。

0-255的这个范围其实很难表示，因为这不是一个整齐的范围，我们采用分段的方式，有如下。

| 范围    | 正则表达式 |
| ------- | ---------- |
| 0-99    | `[1-9]?\d` |
| 100-199 | `1\d{2}`   |
| 200-249 | `2[0-4]\d` |
| 250-255 | `25[0-5]`  |

我们可以采用`|`和`()`将上面几个范围组合起来，构成匹配IP地址的正则表达式。

`(([1-9]?\d|1\d{2}|2[0-4]\d|25[0-5]).){3}([1-9]?\d|1\d{2}|2[0-4]\d|25[0-5])`





## 3. Re库

Re库是Python的标准库，主要用于字符串匹配。

调用方式`import re`。

RE库使用`raw string`类型（原生字符串类型）来表达正则表达式，表示为`r'text'`。

raw string 是不包含转义字符的字符串。如`r'[1-9]\d{5}'`。

正则表达式也可以使用普通的String类型来表示，但是过于繁琐，不推荐。

### 3.1. Re库主要功能函数

| 函数          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| re.search()   | 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象。 |
| re.match()    | 在一个字符串的开始位置起匹配正则表达式，返回match对象。      |
| re.findall()  | 搜索字符串，以列表类型返回全部能匹配的子串。                 |
| re.split()    | 将一个字符串按照正则表达式匹配结果进行分割，返回列表类型。   |
| re.finditer() | 搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象。 |
| re.sub()      | 在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串。 |

* `re.search(pattern, string, flags=0)`

    `pattern`：正则表达式的字符串或原生字符串。

    `string`：待匹配字符串。

    `flags`：正则表达式使用时的控制标记。

    | 常用标记             | 说明                                                         |
    | -------------------- | ------------------------------------------------------------ |
    | re.I = re.IGNORECASE | 忽略正则表达式的大小写，[A-Z]能够匹配小写字符。              |
    | re.M = re.MULTILINE  | 正则表达式中的`^`操作符能够将给定字符串的每行当做匹配开始。  |
    | re.S = re.DOTALL     | 正则表达式中的`.`操作符能够匹配所有字符。默认匹配除换行符以外的所有字符，设置re.S后才可以匹配换行符。 |

    ```python
    >>> import re
    >>> match = re.search(r'[1-9]\d{5}', 'BIT 100080')
    >>> if match:
    ...     print(match.group(0))
    ... 
    100080
    ```

* `re.match(pattern, string, flags=0)`

    `pattern`：正则表达式的字符串或原生字符串。

    `string`：待匹配字符串。

    `flags`：正则表达式使用时的控制标记。

    ```python
    >>> match = re.match(r'[1-9]\d{5}', 'BIT 100080')
    >>> if match:
    ...     print(match.group(0))
    ... 
    >>> match.group(0)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    AttributeError: 'NoneType' object has no attribute 'group'
    >>> match = re.match(r'[1-9]\d{5}', '100080 BIT')
    >>> if match:
    ...     print(match.group(0))
    ... 
    100080
    ```

    re.match()从待匹配字符串开始处开始匹配。

    因为有可能匹配结果为空，所以我们在使用结果前要先判断一下结果集是不是空的。

* `re.findall(pattern, string, flags=0)`

    `pattern`：正则表达式的字符串或原生字符串。

    `string`：待匹配字符串。

    `flags`：正则表达式使用时的控制标记。

    ```python
    >>> ls = re.findall(r'[1-9]\d{5}', 'BIT100080 TSU100084')
    >>> ls
    ['100080', '100084']
    ```

* `re.split(pattern, string, maxsplit=0, flags=0)`

    `pattern`：正则表达式的字符串或原生字符串。

    `string`：待匹配字符串。

    `maxsplit`：最大分割数，剩余部分作为最后一个元素输出。

    `flags`：正则表达式使用时的控制标记。

    ```python
    >>> re.split(r'[1-9]\d{5}', 'BIT100080 TSU100084')
    ['BIT', ' TSU', '']
    >>> re.split(r'[1-9]\d{5}', 'BIT100080 TSU100084', maxsplit=1)
    ['BIT', ' TSU100084']
    ```

* `re.finditer(pattern, string, flags=0)`

    `pattern`：正则表达式的字符串或原生字符串。

    `string`：待匹配字符串。

    `flags`：正则表达式使用时的控制标记。

    ```python
    >>> for m in re.finditer(r'[1-9]\d{5}', 'BIT100080 TSU100084'):
    ...     if m:
    ...             print(m.group(0))
    ... 
    100080
    100084
    ```

* `re.sub(pattern, repl, string, count=0, flags=0)`

    `pattern`：正则表达式的字符串或原生字符串。

    `repl`：替换匹配字符串的字符串。

    `string`：待匹配字符串。

    `count`：匹配的最大替换次数。

    `flags`：正则表达式使用时的控制标记。

    ```python
    >>> re.sub(r'[1-9]\d{5}', ':zipcode', 'BIT100080 TSU100084')
    'BIT:zipcode TSU:zipcode'
    >>> re.sub(r'[1-9]\d{5}', ':zipcode', 'BIT100080 TSU100084', count=1)
    'BIT:zipcode TSU100084'
    ```



#### 3.1.1. Re库的另一种等价用法

Re库有两种常用的调用方法，分别是函数式用法和面向对象用法。

* 函数式用法：一次性操作。

    ```python
    rst = re.search(r'[1-9]\d{5}', 'BIT 100081')
    ```

* 面向对象用法：编译后的多次操作，可以调用上述的6种方法。

    ```python
    pat = re.compile(r'[1-9]\d{5}')
    rsr = pat.search('BIT 100081')
    ```



#### 3.1.2. re.compile()函数

`re.compile()`：将正则表达式的字符穿形式编译成正则表达式对象。

`pattern`：正则表达式的字符串或原生字符串表示。

`flags`：正则表达式使用时的控制标记。

```python
regex = re.compile(r'[1-9]\d{5}')
```

需要注意的是，不论是正则表达式的字符串，还是原生字符串，都只是一个字符串。只有编译后，才是一个正则表达式对象，可以代表一组字符串。

regex对象也具有上述的6种方法。

区别在于，regext没有正则表达式参数，因为他已经用正则表达式编译过了。



### 3.2. Re库的Match对象

```python
>>> match = re.search(r'[1-9]\d{5}', 'BIT 100080')
>>> if match:
...     print(match.group(0))
... 
100080
>>> type(match)
<class 're.Match'>
```

* Match对象的属性

    | 属性    | 说明                           |
    | ------- | ------------------------------ |
    | .string | 待匹配的文本。                 |
    | .re     | 匹配时使用的pattern对象。      |
    | .pos    | 正则表达式搜索文本的开始位置。 |
    | .endpos | 正则表达式搜索文本的结束位置。 |

    ```python
    >>> match.string
    'BIT 100080'
    >>> match.re
    re.compile('[1-9]\\d{5}')
    >>> match.pos
    0
    >>> match.endpos
    10
    ```

* Match对象的方法

    | 方法      | 说明                               |
    | --------- | ---------------------------------- |
    | .group(0) | 获得匹配后的字符串，常用group(0)。 |
    | .start()  | 匹配字符串在原始字符串的开始位置。 |
    | .end()    | 匹配字符串在原始字符串的结束位置。 |
    | .span()   | 返回(.start(), .end())             |

    ```python
    >>> match.group(0)
    '100080'
    >>> match.start()
    4
    >>> match.end()
    10
    >>> match.span()
    (4, 10)
    ```



### 3.1.3. Re库的贪婪匹配和最小匹配

![](https://gukaifeng.cn/posts/python-zhong-de-zheng-ze-biao-da-shi-he-re-ku/Python%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8CRe%E5%BA%93_1.png)

我们看上面的实例，我们的正则表达式匹配有多个可能的结果。

同时匹配长短不同的多项，那么返回的是哪一个呢？

Re库默认采用**贪婪匹配**，即**输出匹配最长的子串**，即结果为`PYANBNCNDN`。

如果想要采用**最小匹配**，即输出匹配最短的子串，即结果为`PYAN`，需要在其中加一个`?`，位置如图。

![](https://gukaifeng.cn/posts/python-zhong-de-zheng-ze-biao-da-shi-he-re-ku/Python%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8CRe%E5%BA%93_2.png)

当有操作符可以匹配不同长度的时候，我们都可以才其后面加上`?`实现最小匹配。

下面是关于最小匹配的一些例子。

| 操作符   | 说明                                    |
| -------- | --------------------------------------- |
| `*?`     | 前一个字符0次或无限次扩展。最小匹配。   |
| `+?`     | 前一个字符1次或无限次扩展。最小匹配。   |
| `??`     | 前一个字符0次或1次扩展。最小匹配。      |
| `{m,n}?` | 扩展前一个字符m至n次（含n）。最小匹配。 |

