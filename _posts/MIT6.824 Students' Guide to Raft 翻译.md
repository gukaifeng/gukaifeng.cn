---
title: "MIT6.824 Students' Guide to Raft 翻译"
date: 2022-04-24 23:30:00
updated: 2022-04-24 23:30:00
categories: [技术杂谈]
tags: [MIT6.824,Raft,论文,分布式]
---



> <font color=red>请注意，此文章尚未完成。</font>  
> <font color=red>当此文章完结时，此声明将被删除。</font>



原文传送门：[Students' Guide to Raft](https://thesquareplanet.com/blog/students-guide-to-raft/)

> 此文章为原文翻译，非本人原创文章！此外，翻译内的人称均和原文保持一致！





在过去的几个月里，我一直是麻省理工学院 [6.824: Distributed Systems](https://pdos.csail.mit.edu/6.824/) 课程的助教。传统上，该课程有许多基于 Paxos 共识算法的实验，但今年，我们决定转向 [Raft](https://raft.github.io/)。Raft 的设计“易于理解”，我们希望这种改变可以让学生的生活更轻松。

这篇文章以及随附的 [Instructors' Guide to Raft](https://gukaifeng.cn/posts/mit6.824-raft-q-a-fan-yi/) 文章记录了我们使用 Raft 的旅程，希望对 Raft 协议的实现者和试图更好地理解 Raft 内部结构的学生有用。如果您正在寻找 Paxos 与 Raft 的比较，或者想要对 Raft 进行更多的教学分析，您应该阅读 Instructors' Guide。这篇文章的底部包含 6.824 名学生常见的问题列表，以及这些问题的答案。如果您遇到本文主要内容中未列出的问题，请查看 [Q&A](https://gukaifeng.cn/posts/mit6.824-instructors-guide-to-raft-fan-yi/)。这篇文章很长，但它提出的所有观点都是很多 6.824 名学生（和助教）遇到的实际问题。这篇文章值得一读。



## 1. 背景

在我们深入研究 Raft 之前，一些上下文可能很有用。6.824 曾经有一组[基于 Paxos 的实验](http://nil.csail.mit.edu/6.824/2015/labs/lab-3.html)，这些实验是用 [Go](https://go.dev/) 构建的；之所以选择 Go，是因为它对学生来说很容易学习，而且非常适合编写并发的分布式应用程序（goroutines 特别方便）。在四个实验的过程中，学生们构建了一个容错的分片键值存储。第一个实验让他们构建了一个基于共识的日志库，第二个实验室在此基础上添加了一个键值存储，第三个实验室在多个容错集群之间分片了键空间，并由一个容错分片主机处理配置更改。我们还有第四个实验，学生必须在其中处理机器的故障和恢复，无论磁盘是否完好，该实验室可作为学生的默认期末项目。

今年，我们决定使用 Raft 重写所有这些实验。前三个实验室都是一样的，但是第四个实验室被放弃了，因为持久性和故障恢复已经内置在 Raft 中。本文将主要讨论我们在第一个实验中的经验，因为它是与 Raft 最直接相关的一个，但我还将涉及在 Raft 之上构建应用程序（如在第二个实验中）。

对于那些刚刚了解 Raft 的人来说，Raft 最好由协议[网站](https://raft.github.io/)上的文本描述：

>Raft is a consensus algorithm that is designed to be easy to understand. It’s equivalent to Paxos in fault-tolerance and performance. The difference is that it’s decomposed into relatively independent subproblems, and it cleanly addresses all major pieces needed for practical systems. We hope Raft will make consensus available to a wider audience, and that this wider audience will be able to develop a variety of higher quality consensus-based systems than are available today.
>
>Raft 是一种旨在易于理解的共识算法。它在容错性和性能上与 Paxos 相当。不同之处在于它被分解为相对独立的子问题，并且清晰地解决了实际系统所需的所有主要部分。我们希望 Raft 能够将共识提供给更广泛的受众，并且这些更广泛的受众将能够开发出比现在可用的各种更高质量的基于共识的系统。

像[这样](http://thesecretlivesofdata.com/raft/)的可视化很好地概述了协议的主要组成部分，并且该论文对为什么需要各种部分提供了很好的直觉。如果你还没有阅读过 [extended Raft](https://raft.github.io/raft.pdf) 论文，那么在继续本文之前你应该先阅读它，因为我假设你对 Raft 相当熟悉。

与所有分布式共识协议一样，细节非常重要。在没有故障的稳定状态下，Raft 的行为很容易理解，并且可以用直观的方式来解释。例如，从可视化中很容易看出，假设没有失败，最终会选出一个领导者，最终发送给领导者的所有操作都将由跟随者以正确的顺序应用。但是，当引入延迟消息、网络分区和故障服务器时，每一个 if、but、和 and 都变得至关重要。特别是，由于阅读论文时的误解或疏忽，我们一遍又一遍地看到了许多错误。这个问题并不是 Raft 独有的，而是在所有提供正确性的复杂分布式系统中都会出现的问题。



## 2. 实现 Raft

Raft 的终极指南在 Raft 论文的图 2 中。该图指定了 Raft 服务器之间交换的每个 RPC 的行为，给出了服务器必须维护的各种不变量，并指定了何时应该发生某些操作。我们将在本文的其余部分大量讨论图 2。它需要信守承诺。

> 查看 Raft 中的图 2
>
> 中文翻译版：https://gukaifeng.cn/posts/raft-lun-wen-yue-du-bi-ji/Raft_Figure_2_Chinese.png  
> 英文原版：https://gukaifeng.cn/posts/raft-lun-wen-yue-du-bi-ji/Raft_Figure_2.png

图 2 定义了每个服务器在任何状态下对每个传入的 RPC 应该做什么，以及何时应该发生某些其他事情（例如何时可以安全地应用日志中的条目）。起初，您可能倾向于将图 2 视为一种非正式指南；你读过一次，然后开始编写一个大致遵循它所说的实现的实现。这样做，您将快速启动并运行大部分工作的 Raft 实现，然后问题就开始了。

事实上，图 2 非常精确，它所做的每一个陈述都应该按照规范的术语来处理，就像**必须**，而不是**应该**。例如，当您收到 `AppendEntries` 或 `RequestVote` RPC 时，您可能会合理地重置对等点的选举计时器，因为两者都表明其他对等点要么认为它是领导者，要么正试图成为领导者。直观地说，这意味着我们不应该干涉。但是，如果您仔细阅读图 2，它会说：

> If election timeout elapses without receiving `AppendEntries` RPC **`from current leader`** or **`granting`** vote to candidate: convert to candidate.
>
> 如果选举超时过去了，没有从当前领导者那里收到 `AppendEntries RPC`，也没有给候选人投票：转换为候选人。

事实证明，这种区别很重要，因为在某些情况下，前一种实现可能会导致活跃度显着降低。



### 2.1. 细节的重要性

为了使讨论更具体，让我们考虑一个让 6.824 名学生绊倒的例子。Raft 论文在很多地方都提到了心跳(**`heartbeat`**) RPCs。具体来说，领导者会偶尔（每个心跳间隔至少一次）向所有对等方发送 `AppendEntries` RPC，以防止它们开始新的选举。如果领导者没有新条目要发送给特定对等方，则 `AppendEntries` RPC 不包含任何条目，并被视为心跳。

我们的许多学生认为心跳在某种程度上是“特殊的”。当对等点收到心跳时，它应该与非心跳 `AppendEntries` RPC 区别对待。特别是，许多人会在收到心跳时简单地重置他们的选举计时器，然后返回成功，而不执行图 2 中指定的任何检查，这是**非常危险的**。通过接受 RPC，追随者隐含地告诉领导者它们的日志与领导者的日志匹配，直到并包括 `AppendEntries` 参数中包含的 `prevLogIndex`。在收到回复后，领导者可能会（错误地）决定某些条目已被复制到大多数服务器，并开始提交它。

许多人遇到的另一个问题（通常在解决上述问题后立即发生）是，在收到心跳后，他们会在 `prevLogIndex` 之后截断追随者的日志，然后附加任何包含在 `AppendEntries` 参数中的条目。 这也是不正确的。我们可以再次转向图 2：

> *If* an existing entry conflicts with a new one (same index but different terms), delete the existing entry and all that follow it.
>
> 如果现有条目与新条目冲突（索引相同但任期不同），删除现有条目及其后面的所有条目。

这里的如果（`if`）很关键。 如果追随者拥有领导者发送的所有条目，则追随者**不得**截断其日志。追随者**必须**保留领导者发送的条目之后的任何元素。这是因为我们可能会从领导者那里收到一个过时的 `AppendEntries` RPC，并且截断日志意味着“收回”我们可能已经告诉领导者我们在日志中的条目。





## 3. 调试 Raft

不可避免地，您的 Raft 实现的第一次迭代将是错误的，第二个也会，以及第三。第四次都会。一般来说，每一个都会比前一个错误更少，并且根据经验，您的大多数错误将是由于不忠实地遵循图 2 造成的。

在调试 Raft 时，通常有四个主要的错误来源：活锁、不正确或不完整的 RPC 处理程序、未遵循规则以及任期混淆。死锁也是一个常见问题，但通常可以通过记录所有锁和解锁来调试它们，并确定您正在使用哪些锁，但不释放。让我们依次考虑每一个。



### 3.1. 活锁

当您的系统活锁时，系统中的每个节点都在做某事，但是您的节点总体上处于这样一种状态，即程序没有取得任何进展。这在 Raft 中很容易发生，特别是如果您不认真地遵循图 2。一种活锁场景尤其经常出现：没有领导者被选举，或者一旦选举了领导者，其他节点开始选举，迫使最近选举的领导者立即退位。

出现这种情况的原因有很多，但是我们看到许多学生犯了一些错误：

* 确保在图 2 中**正确**重置选举计时器。**具体**来说，只有在以下情况下，您才应该重新启动选举计时器：a）您从**当前**领导者那里获得 `AppendEntries` RPC（即，如果 `AppendEntries` 参数中的任期已过时，则**不**应重置计时器）；b) 您正在开始选举；或 c) 您给另一个同行投票**后**。

  最后一种情况在不可靠的网络中尤其重要，因为网络中的追随者可能有不同的日志；在这些情况下，您通常会得到大多数服务器愿意投票支持的少数服务器。如果您在有服务器要求您为他们投票时重置选举计时器，这使得日志过时的服务器与日志较长的服务器一样有可能向前迈进。

  事实上，由于很少有服务器拥有足够的最新日志，这些服务器不太可能能够在足够平静的情况下举行选举以被选举。如果按照图 2 中的规则，日志更新的服务器不会被过时服务器的选举打断，因此更有可能完成选举并成为领导者。

* 请按照图 2 的指示确定何时开始选举。特别要注意，如果您是候选人（即您当前正在进行选举），但选举计时器触发，您应该开始另一次选举。这对于避免由于 RPC 延迟或丢弃而导致系统停止很重要。

* 确保在处理传入 RPC **之前**遵循“服务器规则”中的第二条规则。第二条规则规定：

  > If RPC request or response contains term `T > currentTerm`: set `currentTerm = T`, convert to follower (§5.1)
  >
  > 如果 RPC 请求或响应中包含任期 T > currentTerm：设置 currentTerm = T，转换为追随者（§5.1）

  例如，如果你已经在当前任期内投票过了，但一个传入的 `RequestVote` RPC 的任期比你高，你应该**先**下台并采用他们的任期（因此重置 `votedFor`），**然后**处理 RPC，这将导致你给予投票！



### 3.2. 不正确的RPC处理程序

尽管图 2 准确地说明了每个 RPC 处理程序应该做什么，但仍然很容易忽略一些细微之处。以下是我们一遍又一遍地看到的少数几个，你应该在你的实现中留意：

* 如果某个步骤显示 "reply false"，这意味着您应该**立即回复**，并且不要执行任何后续步骤。
* 如果你得到一个 `AppendEntries` RPC，它的 `prevLogIndex` 指向你的日志末尾之外，你应该像你有那个条目但是其任期不匹配一样来处理它（即，回复 false）。
* 检查 2 是否应该执行 `AppendEntries` RPC 处理程序，**即使领导者没有发送任何条目**。
* AppendEntries 的最后一步（#5）中的 `min` 是**必要的**，它需要与最后一个**新**条目的索引一起计算。当到达日志末尾时，仅让函数在 `lastApplied` 和 `commitIndex` 之间停止应用日志中的内容是**不**够的。这是因为在领导者发送给您的条目之**后**，您的日志中的条目可能与领导者的日志不同（它们都与您的日志中的条目相匹配）。因为 #3 规定只有在条目冲突时才截断日志，这些条目不会被删除，如果 `leaderCommit` 超出了领导者发送给您的条目，您可能会应用不正确的条目。
* **完全按照**第 5.4 节中的描述实施“最新日志”检查非常重要。不作弊，只检查长度！





### 3.3. 未遵守规则

虽然 Raft 论文非常明确地说明了如何实现每个 RPC 处理程序，但它也未指定许多规则和不变量的实现。这些列在图 2 右侧的“服务器规则”块中。虽然其中一些是不言自明的，但也有一些需要非常仔细地设计您的应用程序，以免违反规则：

* 如果在执行期间的任何时候 `commitIndex` > `lastApplied`，您应该应用特定的日志条目。立即执行并不重要（例如，在 `AppendEntries` RPC 处理程序中），但重要的是确保此应用程序仅由一个实体执行。具体来说，您将需要有一个专用的“应用器(applier)”，或者锁定这些应用程序，以使其他一些例程不会也检测到需要应用的条目并尝试应用。
* 确保定期检查 `commitIndex` > `lastApplied`，或者在 `commitIndex` 更新后（即 `matchIndex` 更新后）。例如，如果您在向对等方发送 `AppendEntries` 的同时检查 `commitIndex`，您可能必须等到**下一个**条目追加到日志后，才能应用您刚刚发送并得到确认的条目。
* 如果一个领导者发出一个 `AppendEntries` RPC，它被拒绝了，但**不是因为日志不一致**（这只有在我们的任期已过时才会发生），那么你应该立即下台，而**不是**更新 `nextIndex`。 如果您这样做，如果您立即重新选举，您可以使用重置的 nextIndex 竞争领导者。
* 不允许领导者将 `commitIndex` 更新到**上一个**任期（或者，就此而言，未来任期）的某个地方。 因此，正如规则所说，您特别需要检查 `log[N].term == currentTerm`。 这是因为 Raft 领导者无法确定一个条目是否确实已提交（并且将来永远不会更改），如果它不是来自他们当前的任期。论文中的图 8 对此进行了说明。





一个常见的混淆来源是 `nextIndex` 和 `matchIndex` 之间的区别。 特别是，您可能会观察到 `matchIndex = nextIndex - 1`，而根本没有实现 `matchIndex`。 这是不安全的。 虽然 `nextIndex` 和 `matchIndex` 通常同时更新为相似的值（具体而言，`nextIndex = matchIndex + 1`），但两者的用途截然不同。`nextIndex` 是对领导者与给定追随者共享什么前缀的**猜测**。它通常非常乐观（我们分享一切），并且仅在负面回应时才向后移动。例如，当一个领导者刚刚被选举出来时，`nextIndex` 被设置为日志末尾的索引索引。在某种程度上，`nextIndex` 是用于执行的——你只需要将这些东西发送给这个对等点。

`matchIndex` 用于安全。它是对领导者与给定追随者共享日志前缀的保守**度量**。`matchIndex` 永远不能设置为太高的值，因为这可能会导致 `commitIndex` 向前移动太远。这就是为什么 `matchIndex` 被初始化为 -1（即我们同意不使用前缀），并且仅在追随者肯定地确认 `AppendEntries` RPC 时更新。

​	

### 3.4. 任期混淆



任期混淆是指服务器被来自旧任期的 RPC 混淆。一般来说，接收 RPC 时这不是问题，因为图 2 中的规则准确地说明了当您看到旧任期时应该做什么。但是，图 2 通常不会讨论在收到旧的 RPC 的**回复**时应该做什么。根据经验，我们发现目前为止最简单的做法是先记录回复中的任期（可能高于您当前的任期），然后将当前任期与您在原始 RPC 中发送的任期进行比较。如果两者不同，请放弃回复并返回。**只有**当这两个任期相同时，您才能继续处理回复。您可以在这里通过一些巧妙的协议推理进行进一步优化，这种方法似乎效果很好，**不**这样做会导致一条漫长而曲折的血腥、汗水、眼泪和绝望之路。

一个相关但不完全相同的问题是，假设您的状态在您发送 RPC 和收到回复之间没有改变。一个很好的例子是在收到对 RPC 的响应时设置 `matchIndex = nextIndex - 1` 或 `matchIndex = len(log)`。这是**不**安全的，因为这两个值都可能在您发送 RPC 后已更新。相反，正确的做法是根据您最初在 RPC 中发送的参数将 `matchIndex` 更新为 `prevLogIndex + len(entries[])`。



### 3.5. 说说优化

Raft 论文包括几个有趣的可选特性。在 6.824 中，我们要求学生实现其中两个：日志压缩（Log Compaction，论文第 7 节）和加速日志回溯（论文第 8 页左上角）。前者对于避免日志无限制增长是必要的，后者对于快速更新旧的追随者很有用。

这些特性不是“Raft 核心”的一部分，所以在论文中没有像主要共识协议一样受到关注。日志压缩被相当彻底覆盖（在图13中），但遗漏了一些设计细节，如果您过于随意地阅读，可能会错过这些细节：



* 在给应用程序状态创建快照时，您需要确保应用程序状态与 Raft 日志中的某些已知索引相对应。这意味着该应用程序要么需要进行通信来知道快照对应的索引是什么，要么 Raft 需要延迟应用其他日志条目，直到快照完成为止。

* 本文没有讨论服务器崩溃和恢复时的恢复协议，因为现在涉及到快照。特别是，如果分别提交 Raft 状态和快照，服务器可能会在持久化快照和持久化更新的 Raft 状态之间崩溃。这是一个问题，因为图 13 中的步骤 7 规定快照覆盖的 Raft 日志**必须被丢弃**。

  当一个服务器恢复时，如果它读取更新的快照，但读取过期的日志，那么它可能最终应用**快照中已经包含的**一些日志条目。发生这个问题是由于 `commitIndex` 和 `lastApplied` 没有持久化，所以 Raft 不知道这些日志条目已经应用了。解决这个问题的方法是向 Raft 引入一个持久状态，记录 Raft 持久日志中的第一个条目对应的“真实”索引。然后可以将其与加载的快照的 `lastIncludedIndex` 进行比较，以确定要丢弃日志头部的哪些条目。



加速日志回溯优化并没有详细说明，这可能是因为作者认为大多数部署都不需要它。从文本中并不清楚从客户端返回的冲突索引和任期应该如何被领导者用来确定使用什么 nextIndex。我们认为作者**可能**希望你遵循的协议是：

* 如果追随者的日志中没有 `preLogIndex`，它应该返回 `conflictIndex = len(log)` 和 `conflictTerm = None`。
* 如果追随者的日志中有 `preLogIndex`，但是任期不匹配，它应该返回 `conflictTerm = log[preLogIndex].Term`，然后在它的日志中搜索任期等于 `conflictTerm` 的第一个条目索引。
* 在收到一个冲突响应后，领导者首先应该搜索其日志中任期为 `conflictTerm` 的条目。如果领导者在其日志中找到此任期的一个条目，则应该设置 `nextIndex` 为其日志中此任期的最后一个条目的索引的下一个。
* 如果领导者没有找到此任期的条目，则应该设置 `nextIndex = conflictIndex`。



一个折中的解决方案是，只使用 `conflictIndex`（忽略 `conflictTerm`），简化实现，但是这样领导者有时将最终向追随者发送更多的日志条目，而不是严格使它们保持最新的必要条件。



## 4. Raft 上的应用程序



