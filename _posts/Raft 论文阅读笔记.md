---
title: Raft 论文阅读笔记
date: 2022-04-08 00:47:00
updated: 2022-04-12 01:03:00
categories: [论文阅读笔记]
tags: [Raft,论文,分布式]
---





> <font color=red>请注意，此文章尚未完成。</font>  
> <font color=red>当此文章完结时，此声明将被删除。</font>







Raft 论文原文传送门：  
[In Search of an Understandable Consensus Algorithm (Extended Version)](https://raft.github.io/raft.pdf)



> 这篇文章大头是原文翻译，但我在很多地方加入了自己的理解，  
> 主要作为我自己的笔记，不保证读者可以看懂，但你若有问题可以写在评论区，我会回复。



## 0. 摘要



Raft 是一种用于管理复制日志的一致性算法。

Raft 产生的结果和 (multi-)Paxos 一样，并且和 Paxos 一样高效，但是 Raft 的结构和 Paxos 不同。这使 Raft 比 Paxos 更容易理解，也为在构建实际系统提供了更好的基础。

为了更容易理解，Raft 分离了一致性的关键要素，例如领导选举(leader election)，日志复制(log replication)和安全性(safety)。

Raft 加强了一致性，以减少必须考虑的情况的数目。

一个用户研究的结果说明，对于学生来说，Raft 比 Paxos 更容易学。

Raft 还包括一种用于更改集群成员的新机制，该机制使用重叠多数(overlapping majorities)来保证安全。



## 1. 导论



一致性算法允许一组机器作为一个一致的组来工作，这个组能够在其部分成员故障时幸存。因此，在构建可靠的大规模软件系统中，一致性算法扮演着关键的角色。在过去十年间，关于一致性算法的讨论被 Paxos 统治：大部分一致性实现都是基于 Paxos 或受 Paxos 影响的，并且 Paxos 成为了给学生讲关于一致性内容的主要工具。

不幸的是，尽管有数次让 Paxos 更平易近人的尝试，其还是相当难于理解。此外，Paxos 的架构需要复杂的修改以支持实际的系统。结果就是，系统构建者和学生都在为 Paxos 苦苦挣扎。

在我们与 Paxos 斗争之后，我们开始寻找一个新的一致性算法，期望此算法能够为系统构建和教育提供更好的基础。我们的主要目标是**可理解性**，我们的方法不太寻常：我们能否为实际系统定义一个一致性的算法，并且以比 Paxos 容易学得多的方式描述这个算法？此外，我们希望此算法能够促进对系统构建者至关重要的直觉的发展。不仅仅是算法能够工作很重要，能明显看出为什么可以工作也很重要。

这项工作的结果就是一个名为 Raft 的一致性算法。在设计 Raft 过程中，我们应用了特定的技术来提高可理解性，包括分解（Raft 分离了领导选举，日志复制和安全性）和减小状态空间（相对于 Paxos，Raft 降低了非确定性的程度以及服务器之间可能不一致的方式）。一个包含了来自两所大学的 43 个学生的用户研究表明，Raft 比 Paxos 容易理解的多得多：在学习了两个算法以后，33/43 个学生在回答关于 Raft 的问题时比回答关于 Paxos 的问题是表现更好。

Raft 在很多方面都和现存的一致性算法类似（最显著的是，Oki 和 Liskov 的 Viewstamped Replication），但 Raft 有几个新颖的特征：

* **强领导者(Strong leader)：**Raft 使用比其他一致性算法更强大的领导形式。例如，日志条目仅从领导者流向其他服务器。这简化了对复制日志的管理，并使 Raft 更易于理解。
* **领导选举(Leader election)：**Raft 使用随机计时器来选举领导者。这只会为任何一致性算法已经需要的心跳(HeartBeat)添加少量机制，同时简单快速地解决冲突。
* **成员变更(Membership changes)：**Raft 用来变更集群中服务器集合的机制中使用了一个新的方法 — **联合一致性(joint consensus)**，在两个不同的配置中，大部分机器在转换期间重叠，这允许集群在成员变更期间继续正常运行。

不管是以教育为目的，还是作为实现基础，我们都认为 Raft 比 Paxos 和其他一致性算法更好。Raft 比其他一致性算法更简单、更好理解；Raft 的描述足够完整，足以满足实际系统的需要；Raft 有几个开源实现，有几个公司在使用 Raft；Raft 的安全特性已被正式规定和证明；Raft 的效率与其他算法相当。

这篇论文的剩余部分介绍了复制状态机问题（第 2 节），讨论了 Paxos 的优缺点（第 3 节），描述了我们理解可理解性的一般方法（第 4 节），介绍 Raft 一致性算法（第 5-8 节），评估 Raft（第 9 节），最后讨论了相关工作（第 10 节）。



## 2. 复制状态机(Replicated state machines)



一致性算法通常出现在**复制状态机(Replicated state machines)**的上下文中。在这个方法中，服务器集合上的状态机计算同一状态的相同副本，并且即使某些服务器 down 机了也可以继续运行。复制状态机用于解决分布式系统中的各种容错问题。例如，在像 GFS、HDFS 和 RAMCloud 这样的只有单个集群领导者的大规模系统中，通常使用单独的复制状态机来管理领导选举并存储必须在领导者崩溃后幸免的配置信息。在 Chubby 和 ZooKeeper 中有复制状态机的例子。







![图 1：复制状态机架构。一致性算法管理一个复制日志，其中包含来自客户端的状态机命令。这个状态机处理来自日志的相同命令序列，所以它们产生一样的输出。](https://gukaifeng.cn/posts/raft-lun-wen-yue-du-bi-ji/Raft_Figure_1.png)





复制状态机一般使用复制日志实现，如图 1。每个**服务器(Server)** 存储一个包含了一系列命令的**日志(Log)**，其**状态机(State Machine)** 按顺序执行这些命令。每个日志包含相同顺序的相同命令，所以每个状态机处理相同的命令序列。由于状态机是确定性的，因此每个状态机计算相同的状态和相同的输出序列。

保持复制日志一致是一致性算法的工作1。① 服务器上的**一致性模型(Consensus Module)** 接收来自**客户端(Client)** 的命令，② 把这些命令添加到服务器的日志中，且和其他服务器上的一致性模型通信以确保每个日志最终包含相同顺序的相同请求，即便一些服务器故障了。一旦命令被正确复制，③ 每个服务器的状态机都会按日志顺序处理它们，并 ④ 将输出返回给客户端。 结果，服务器似乎形成了一个单一的、高度可靠的状态机。

对于实际系统，一致性算法往往有以下属性：

* 一致性算法确保所有 non-Byzantine 条件下的安全性（永远不会返回错误的结果），包括网络延迟、分区、丢包、重复和重新排序。
* 只要大多数服务器都可以运行，可以相互通信，可以与客户端通信，一致性算法就可以正常工作（可用）。因此，一个典型的五台服务器集群可以容忍任何两台服务器的故障。假设服务器因停止而故障，它们稍后可能会从稳定存储上的状态恢复并重新加入集群。
* 一致性算法不依赖于时间来确保日志的一致性：错误的时钟和极端的消息延迟在最坏的情况下会导致可用性问题。
* 在一般情况下，只要集群的大部分响应了一轮远程过程调用，命令就可以完成。少数慢速服务器不需要影响整体系统性能。







## 3. Paxos 有什么问题？



在过去的时间里，Leslie Lamport 的 Paxos 协议成为了“一致性”的同义词：大学里关于一致性协议的课程中教 Paxos 的最常见，大部分一致性实现使用 Paxos 作为起点。Paxos 首先定义了一种能够就单个决策达成一致的协议，例如单个复制日志条目，我们将此子集称为**单法令 Paxos (single-decree Paxos)**。然后 Paxos 结合了该协议的多个实例，以促进一系列决策，例如日志，这种情况称为 **multi-Paxos**。Paxos 确保了安全性和活跃性，并且它支持集群成员变更。Paxos 的正确性已经被证明，并且在正常情况下是有效的。

不幸的是，Paxos 有两个严重的缺点。

第一个缺点是，Paxos 非常非常难理解，其完整的解释是出了名的晦涩难懂，很少有人能仅仅通过付出巨大的努力就能成功理解。因此，已经有几次尝试（几篇论文）用更简单的术语来解释 Paxos，这些解释聚焦 single-decree 子集，然而这些仍然具有挑战性。在 NSDI 2012 对出席者的非正式调查中，我们发现很少有人对 Paxos 感到满意，即使是经验丰富的研究人员也是如此。我们自己在 Paxos 上苦苦挣扎，直到我们阅读几个简化的解释，并设计了我们自己的替代协议以后，我们才能理解完整的 Paxos 协议，这个过程花了几乎一年的时间。

我们假设 Paxos 的晦涩难懂源于它选择单一法令子集作为其基础。Single-decree Paxos 是密集和微妙的：分为两个阶段，没有简单直观的解释，无法独立理解。正因为如此，很难对 single-decree 协议的工作原理产生直觉。multi-Paxos 的组合规则显着增加了复杂性和微妙性。我们相信，就多个决策（即日志而不是单个条目）达成一致性的整体问题可以用其他更直接和明显的方式分解。

第二个缺点是，Paxos 没有为构建实际实现提供一个好的基础。一个原因是，对于 multi-Paxos，没有广泛认可的算法。Lamport 的描述大部分是关于 single-decree Paxos 的，他勾勒出了实现 multi-Paxos 的可能方法，但缺少许多细节。尽管已经有多次尝试充实和优化 Paxos，但它们彼此不同，也与 Lamport 的草图不同。像 Chubby 这样的系统已经实现了类 Paxos 算法，但在大多数情况下，它们的细节还没有公布。



此外，Paxos 架构对于构建实际系统来说是一种糟糕的架构，这是 single-decree 分解的另一个结果。例如，单独选择一组日志条目然后将它们融合到一个顺序日志中几乎没有什么好处，这只会增加复杂性。围绕日志设计一个系统更简单、更有效，其中新条目以受约束的顺序顺序追加。另一个问题是 Paxos 在其核心使用了一种对称的点对点方法（尽管 Paxos 最终提出了一种弱领导形式作为性能优化），这在一个只会做出一个决定的简化世界中是有意义的，但很少有实际系统使用这种方法。如果必须做出一系列决策，首先选举领导者，然后让领导者协调决策更简单、更快捷。

因此，实际系统与 Paxos 几乎没有相似之处。每个实现都从 Paxos 开始，发现实现它的困难，然后开发出截然不同的架构，这既费时又容易出错，而且理解 Paxos 的困难加剧了这个问题。Paxos 的公式可能是证明其正确性定理的好方法，但实际实现与 Paxos 如此不同，以至于证明没有什么价值。Chubby 实现者的以下评论很典型：

> Paxos 算法的描述与现实世界系统的需求之间存在很大差距 ...... 最终系统将基于未经证实的协议。

因为上述这些问题，我们认为无论是对于系统构建还是对于教育，Paxos 都不能提供一个好的基础。考虑到在大规模集群中一致性的重要性，我们决定看看我们是否可以设计一种性能比 Paxos 更好的替代一致性算法。Raft 就是那个实验的结果。



## 4. 为可理解性而设计



我们在设计 Raft 时有几个目标：它必须为系统构建提供完整实用的基础，从而显着减少开发人员所需的设计工作量；它必须在所有条件下都是安全的，并且在典型的操作条件下可用；并且对于常见的操作必须是高效的。但我们最重要的目标，也是最困难的挑战是**可理解性**。大量读者必须能够轻松地理解算法。此外，必须有可能开发出对算法的直觉，以便系统构建者可以进行在现实世界实现中不可避免的扩展。

在 Raft 的设计中有很多点我们必须在替代方法中进行选择。在这些情况下，我们根据可理解性评估备选方案：解释每个备选方案有多难（例如，它的状态空间有多复杂，是否有微妙的含义？），以及读者完全理解该方法及其含义的难易程度如何。

我们认识到这种分析具有高度的主观性；尽管如此，我们还是使用了两种普遍适用的技术。第一种技术是众所周知的问题分解方法：只要可能，我们将问题分成可以相对独立地解决、解释和理解的独立部分。例如，在 Raft 中，我们将领导选举、日志复制、安全性和成员变更分开。

我们的第二种方法是通过减少要考虑的状态数量来简化状态空间，使系统更加一致并在可能的情况下消除不确定性。具体来说，日志不允许有洞，Raft 限制了日志相互不一致的方式。尽管在大多数情况下我们试图消除不确定性，但在某些情况下，不确定性实际上提高了可理解性。特别是，随机方法引入了非确定性，但它们倾向于通过以类似方式处理所有可能的选择来减少状态空间（“选择任何都没有关系”）。我们使用随机化来简化 Raft 领导选举算法。





## 5. Raft 一致性算法

Raft 是一种用于管理第 2 节中描述的形式的复制日志的算法。图 2 以精简形式总结了该算法以供参考，图 3 列出了该算法的关键属性。这些图的元素将在本节的其余部分进行分段讨论。

Raft 实现一致性的方式是，首先选举出一个杰出的**领导者**，然后让这个领导者全权管理复制日志。这个领导者从客户端接受日志条目，在其他服务器上复制这些条目，并告诉服务器何时将这些日志条目应用到他们的状态机是安全的。使用领导者简化了复制日志的管理。例如，领导者能够决定在日志中放置新条目的位置，而无需与其他服务器商量，并且数据流以一个简单的方式从领导者流向其他服务器。领导者可能会失败或与其他服务器断开连接，在这种情况下会选出新的领导者。

鉴于领导者方法，Raft 将一致性问题分解为三个相对独立的子问题，这些子问题将在以下小节中讨论：

* 领导选举：当现存的领导者故障时，必须选出一个新的领导者（第 5.2 节）。
* 日志复制：领导者必须接受来自客户端的日志条目，并把这些条目跨集群复制，强制其他日志与自己的一致（第 5.3 节）。
* 安全性：Raft 的关键安全属性是图 3 中的状态机安全属性(State Machine Safety Property)：如果任何服务器已将特定日志条目应用到其状态机，则没有其他服务器可以为相同的日志索引应用不同的命令。第5.4 节描述了 Raft 如何确保这个属性，该解决方案涉及对第 5.2 节中描述的选举机制的额外限制。

在介绍了一致性算法之后，本节讨论了可用性问题和时间在系统中的作用。



此图 2 为翻译版本，在[这里](https://gukaifeng.cn/posts/raft-lun-wen-yue-du-bi-ji/Raft_Figure_2.png)查看原图。

![图 2：Raft 一致性算法的精简摘要（不包括成员变更和日志压缩(compaction)）。左上方框中的服务器行为被描述为一组独立且重复触发的规则。§5.2 等章节编号表示讨论特定功能的位置。](https://gukaifeng.cn/posts/raft-lun-wen-yue-du-bi-ji/Raft_Figure_2_Chinese.png)



![图 3：Raft 保证这些属性中的每一个在任何时候都是正确的。章节编号表示每个属性的讨论位置。](https://gukaifeng.cn/posts/raft-lun-wen-yue-du-bi-ji/Raft_Figure_3.png)



### 5.1. Raft 基础

一个 Raft 集群包含几个服务器：一般是 5 个，即可以容忍系统中有 2 个服务器故障。在任何给定的时间，每个服务器都处于三种状态之一：**领导者(leader)**、**追随者(follower)**和**候选人(candidate)**。在一般的操作中，有一个确定的领导者，所有其他的服务器都是追随者。追随者是被动的：他们自己不发出请求，而只是响应来自领导者和候选人的请求。领导者处理所有的客户端请求（如果一个客户端和追随者联系，追随者会把其重定向到领导者）。第三个状态，候选人，用于选举一个新的领导者，像在第 5.2 节描述的那样。图 4 显示了这些状态以及状态之间的转换，转换规则在下面讨论。

![图 4：服务器状态。追随者只响应来自其他服务器的请求。如果追随者没有收到任何通信，他将成为候选人并发起选举。获得整个集群中大部分服务器选票的候选者成为新的领导者。领导者通常会一直工作，直到故障。](https://gukaifeng.cn/posts/raft-lun-wen-yue-du-bi-ji/Raft_Figure_4.png)

Raft 将时间划分为任意长度的**任期(terms)**，如图 5 所示。任期用连续的整数编号。每个任期都以选举(election)开始，其中一个或多个候选人尝试成为第 5.2 节所述的领导者。如果一个候选人赢得选举，他就会在这个任期的剩余时间内担任领导者。在某些情况下，选举将导致分裂投票。在这种情况下，任期将在没有领导者的情况下结束，一个新的任期（带着新的选举）将很快开始。Raft 确保在给定的任期内最多有一个领导者。



![图 5：将时间划分为任期(terms)，每个任期以一个选举开始。选举成功后，一个领导者管理这个集群，直到任期结束。某些选举可能失败，这种情况下，任期将在没有领导者的情况下结束。任期之间的转换可以在不同服务器上的不同时间观察到。](https://gukaifeng.cn/posts/raft-lun-wen-yue-du-bi-ji/Raft_Figure_5.png)





不同的服务器可能会在不同的时间观察术语之间的转换，并且在某些情况下，服务器可能不会观察到选举甚至整个任期。任期在 Raft 中充当逻辑时钟，它们允许服务器检测过时的信息，例如过时的领导者。每个服务器存储一个**当前任期**编号，该编号随时间单调增加。每当服务器通信时，都会交换当前任期编号，如果一台服务器的当前任期编号小于另一台服务器的当前任期编号，则它会将其当前编号更新为较大的值。如果候选人或领导者发现其任期已过时，它将立即恢复为追随者状态。如果服务器收到具有过时任期编号的请求，它将拒绝该请求。

Raft 服务器通过远程过程调用(RPC)通信，基本的一致性算法只需要两种类型的 RPC 请求：**请求投票 RPC (RequestVote RPC)** 由候选人在选举期间发起（第 5.2 节），**追加条目 RPC (AppendEntries RPC)** 由领导者发起以复制日志条目并提供一种心跳形式。第 7 节添加了第三个 RPC，用于在服务器之间传输快照(snapshot)。 如果服务器没有及时收到响应，则服务器会重试 RPC，并且它们会并行发出 RPC 以获得最佳性能。



### 5.2. 领导选举

Raft 使用心跳机制来触发领导选举。当服务器启动时，他们一开始先作为追随者。只要服务器从领导者或候选人那里收到有效的 RPC，他就会保持追随者状态。领导者定期发送心跳（不携带日志条目的追加条目 RPC）给所有追随者，以维护这些追随者的权限。如果一个追随者在称为**选举超时(election timeout)**的一段时间内没有收到任何通信，则它假定没有可行的领导者并开始选举以选择新的领导者。

要开始选举，一个追随者会增加其当前任期并转换到候选人状态，随后给自己投一票，并给集群中每个其他服务器并行发出请求投票 RPC。一个候选人会持续其候选人状态直到发生下面三件事之一：**(a)** 它赢得选举，**(b)**  另一台服务器将自己建立为领导者，或 **(c)** 一个时间周期过去，但没有服务器赢得选举。这些结果将在下面的段落中单独讨论。

如果一个候选人在同一任期内获得来自整个集群中大部分服务器的选票，它就会赢得选举。在给定的任期内，每个服务器最多只能给一个候选人投票，基于先来先服务(first-come-first-served)（注意：第 5.4 小节增加了对投票的额外限制）。这个大多数规则确保了在一个指定的任期内最多只有一个候选人可以胜出（图 3 中的 Election Safety Property）。一旦一个候选人赢得选举，它就成为了领导者，随后它就会给所有其他服务器发送心跳消息以建立它的权威，并阻止新的选举。

在等待投票时，候选人可能会从另一个声称自己是领导者的服务器收到追加条目 RPC。如果这个领导者的任期（任期信息包含在 RPC 中）至少和这个候选人的当前任期一样大，候选人就会意识到这个领导者是合法的，然后返回追随者状态。如果这个领导者的任期小于这个候选人的当前任期，候选人就会拒绝这个 RPC 并继续保持候选人状态。

第三个可能的结果是，一个候选人既没有赢得选举，也没有输掉选举：如果很多追随者在同一时间成为候选人，选票就会被划分（分裂）的太多，导致没有任何一个候选人可以获得大多数选票（大多数选票指的是票数超过总服务器数量的一半，例如，5 个服务器时，获得至少 3 张选票的候选人会胜出）。在这种情况下，每个候选人都会超时，并开始一个新的选举（增加其任期编号，发起另一轮请求投票 RPC）。然而，如果没有额外的措施，分裂投票可能无限重复。

Raft 使用随机选举超时来确保分裂投票很少发生并且可以快速解决。首先，为了防止分裂投票，选举超时是从固定区间（例如，150-300 ms）中随机选择的。这分散了服务器，因此在大多数情况下，<font color=red>只有一个服务器会超时</font>，它赢得了选举并在任何其他服务器超时之前发送心跳。相同的机制用于处理分裂投票。每个候选人在选举开始时重新开始其随机选举超时，并在开始下一次选举之前等待该超时过去<font color=red>（也就是这段超时时间内选举没有实际进行，每个候选人都空等一次超时）</font>，这减少了在新选举中再次分裂投票的可能性。第 9.3 节表明，这种方法可以快速选举领导者。

选举是可理解性如何引导我们在设计备选方案之间进行选择的一个例子。最初我们计划使用排名系统：为每个候选人分配一个唯一的排名，用于在竞争候选人之间进行选择。如果一个候选人发现另一个候选人有更高的排名，他就会回到追随者状态，所以有更高排名的候选人更容易赢得下一次选举。我们发现这种方法在可用性方面产生了微妙的问题（如果排名较高的服务器发生故障，排名较低的服务器可能需要超时并再次成为候选者，但如果它过早地这样做，它可能会重置选举领导者的进度）。我们对排名系统算法进行了多次调整，但每次调整后都会出现新的极端情况。最终我们得出结论，随机重试的方法更加明显和易于理解。









### 5.3.  日志复制







### 5.4. 安全性 



#### 5.4.1. 选举限制



#### 5.4.2. 提交以前任期中的条目



#### 5.4.3. 安全性论证



### 5.5. 追随者和候选人崩溃



### 5.6. 时间和可用性

