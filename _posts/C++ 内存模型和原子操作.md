---
title: "C++ 内存模型和原子操作"
date: 2023-02-02 22:30:00
updated: 2023-02-02 22:30:00
categories: [并发编程]
tags: [Cpp,并发编程]
---





> C++ 新标准引入了不少新特性，其中一项非常重要，它既不是新的语法功能，也不是新的程序库工具，而是新的线程感知的内存模型，却被大多数程序员锁忽略。内存模型精确定义了基础构建单元应当如何运转。唯有以内存模型为基石，C++ 提供的并发工具方能可靠的工作。多数程序员之所以会忽略内存模型，是因为我们只需要借助互斥保护数据，并采用条件变量、future、线程闩或线程卡来触发事件信号，就足以将多线程运用自如，结果甚少有人深究底层细节。只有当我们尽力“贴近计算机底层硬件”，内存模型的精确细节的重要作用才会彰显。
>
> 不论其他语言如何定位，C++ 都是操作系统级别的编程语言。C++ 标准委员会的一个目标是领 C++ 尽量贴近计算机底层，而不必改用其他更低级的语言，C++ 十分灵活，可满足程序员的许多需求，包括容许他们在必要时“贴近计算机底层硬件”，语言本身不应构成障碍。原子类型(atomic)及其操作应运而生，提供了底层同步操作的功能，其常常只需一两条 CPU 指令即可实现。



## 1. 内存模型基础

内存模型牵涉两个方面：基本结构和并发。基本结构关系到整个程序在内存中的布局。它对并发很重要，尤其是在我们分析底层原子操作的时候。所以这里从基本结构开始介绍。就 C++ 而言，归根结底，基本结构就是对象和内存区域。





### 1.1. 对象和内存区域

C++ 标准中定义的“对象”与我们平常理解的不同，其**将“对象”定义为“某一存储范围(a region of storage)”**。

由此定义出发，C++ 程序的数据全部都有对象构成。这些对象中，有的数据内建基本类型（如 int 和 float），用于存储简单的数值，其他则是用户自定义类型的实例。某些对象具有子对象，如数列、派生类的实例、含有非静态数据成员的类的实例等，而其他则没有。

不论对象属于什么类型，它都会存储在一个或多个内存区域中。每个内存区域或是对象/子对象，属于标量类型(scalar type)，如 unsigned int 和 my_class*，或是一串连续的位域（注意位域有一项重要的性质：尽管相邻的位域分属不同的对象，但照样算作同一内存区域）。



下图是一个示例：



![图：将结构体分解为对象和内存区域](https://gukaifeng.cn/posts/c-nei-cun-mo-xing-he-yuan-zi-cao-zuo/c-nei-cun-mo-xing-he-yuan-zi-cao-zuo_1.png)



图的左边，是一个结构体的代码，右边是其对应的对象和内存区域。





### 1.2. 对象、内存区域和并发



### 1.3. 改动序列







## 2. C++ 中的原子操作及其类别



## 3. 同步操作和强制次序



## 4. 小结 