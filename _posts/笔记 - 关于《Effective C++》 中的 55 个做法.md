---
title: "笔记 - 关于《Effective C++》 中的 55 个做法"
date: 2023-03-19 17:25:00
updated: 2023-03-19 17:25:00
categories:
- 编程语言基础
- Cpp
tags: [Cpp]
---



最近闲来无事，想起了之前买的《Effective C++（第三版）》这本书，就打算看一下。

书中介绍了改善程序与设计的 55 个具体做法，但本文并不会像书中那样对相关问题进行分析，而是直接给出结论和重点（个别也会简单解释）。

如果你在阅读此文章，那么我认为，在大部分场景下，你可以直接采用这些结论，因为不满足这些结论的情况是比较少的。**但如果你有时间，还是建议阅读原书，理解这些结论从何而来，以及在哪些情况下可能不适用。**



下面的笔记顺序，与原书的结构顺序一致，每个做法称为一个“条款”。



## 1. 让自己习惯 C++

### 条款 01：将 C++ 视为一个语言联邦



* **C++ 高效编程守则视状况而变化，取决于你使用 C++ 的哪一部分。**



作者认为 C++ 可以视为一个由相关语言组成的联邦，而非单一语言。在其某个次语言(sublanguage)中，各种守则与通例都倾向简单、直观易懂、并且容易记住。当我们由一个次语言换到另一个次语言的时候，守则可能会改变。这里的守则和通例我理解为一些编程方法、技巧、倾向性（比如两种方案都能实现目标，那么更应当选择哪个方法）等。

作者划分的次语言共有四个：

1. C part of C++ ：即 C++ 仍是以 C 为基础的，这里指的就是采用 C 语言编程的部分。
2. Object-Oriented C++ ：即 C with Classes，包含 class 的各种特性。
3. Template C++ ：C++ 的泛型编程部分。
4. STL  ：STL 是个 template 程序库，其有自己特殊的办事方式，当我们使用 STL 时需要遵守它的规约。



记住这四个次语言，当你从某个次语言切换到另一个，可能会导致高效编程守则要求你改变策略。例如对内置（也就是 C-like）类型而言 *pass-by-value* 通常比 *pass-by-reference* 高效，但当你从 C part of C++ 移往 Object-Oriented C++， 由于用户自定义(user-defined)构造函数和析构函数的存在，*pass-by-reference-to-const* 往往更好。运用 Template C++ 时尤其如此，因为彼时你甚至不知道所处理的对象的类型。然而一旦跨入 STL 你就会了解，迭代器和函数对象都是在 C 指针之上塑造出来的，所以对 STL 的选代器和函数对象而言，旧式的 C *pass-by-value* 守则再次适用（参数传递方式的选择细节请见条款 20）。





### 条款 02：尽量以 const, enum, inline 替换 #define



* **对于单纯常量，最好以 `const` 对象或 `enum` 替换 `#define`。**
* **对于形似函数的宏(macros)，最好改用 `inline` 函数替换 `#define`。**



这个条款也可以改为“宁可以编译器替换预处理器”，即核心思想是多让编译器做事，少让预处理器做事（`#define` 是由预处理处理的）。





### 条款 03：尽可能使用 const



* **将某些东西声明为 `const` 可帮助编译器侦测出错误用法。`const` 可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。**
* **编译器强制实施 bitwise constness，但你编写程序时应该使用“概念上的常量性”(conceptual constness) 。**
* **当 `const` 和非 `const `成员函数有着实质等价的实现时，令非 `const` 版本调用 `const` 版本可避免代码重复。**





### 条款 04：确定对象被使用前已先被初始化



* **为内置型对象进行手工初始化，因为 C++ 不保证初始化它们。**

* **构造函数最好使用成员初值列(member initialization list)，而不要在构造函数本体内使用赋值操作(assignment)。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。**
* **为免除“跨编译单元之初始化次序”问题，请以 local static 对象替换 non-local static 对象。**



## 2. 构造/析构/赋值运算

### 条款 05：了解 C++ 默默编写并调用哪些函数

* **编译器可以暗自为 class 创建默认构造函数、拷贝构造函数、拷贝赋值操作符，以及析构函数。**

### 条款 06：若不想使用编译器自动生成的函数，就该明确拒绝

* **为驳回编译器自动（暗自）提供的机能，可将相应的成员函数声明为 `private` 并且不予实现。使用 Uncopyable 这样的基类也是一种做法。**

### 条款 07：为多态基类声明 virtual 析构函数

* **具备多态性的基类应该声明一个 `virtual` 析构函数。如果一个 class 带有任何 `virtual` 函数，那么它就应该拥有一个 `virtual` 析构函数。**
* **一个 class 的设计目的如果不是作为基类使用，或不是为了具备多态性，就不该用 `virtual` 析构函数。**

### 条款 08：别让异常逃离析构函数

* **析构函数绝对不要抛出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞掉（不传播）这些异常或结束程序。**
* **如果需要对某个操作函数运行期间抛出的异常做出反应，那么 class 应该提供一个普通函数执行该操作，而非在析构函数中。**

### 条款 09：绝不在构造和析构过程中调用 virtual 函数

### 条款 10：令 operator= 返回一个 *reference to \*this*

### 条款 11：在 operator= 中处理“自我赋值”

### 条款 12：复制对象时勿忘其每一个成分



## 3. 资源管理

### 条款 13：以对象管理资源

### 条款 14：在资源管理类中小心 copy 行为



### 条款 15：在资源管理类提供对原始资源的访问

### 条款 16：成对使用 new 和 delete 时要采取相同形式

### 条款 17：以独立语句将 new 得到的对象置入智能指针



## 4. 设计与声明



### 条款 18：让接口容易被正确使用，不易被误用

### 条款 19：设计 class 犹如设计 type

### 条款 20：宁以 pass-by-reference-to-const 替换 pass-by-value

### 条款 21：必须返回对象时，别妄想返回其 reference

### 条款 22：将成员变量声明为 private

### 条款 23：宁以 non-member、non-friend 替换 member 函数

### 条款 24：若所有参数皆需类型转换，请为此采用 non-member 函数

### 条款 25：考虑写出一个不抛异常的 swap 函数





## 5. 实现

### 条款 26：尽可能延后变量定义式的出现时间

### 条款 27：尽量少做转型动作

### 条款 28：避免返回 handles 指向对象内部成分

### 条款 29：为“异常安全”而努力是值得的

### 条款 30：透彻了解 inline 的里里外外

### 条款 31：将文件间的编译依存关系降至最低



## 6. 继承与面向对象设计



### 条款 32：确定你的 public 继承塑模出 "is-a" 关系

### 条款 33：避免隐藏继承而来的名称

### 条款 34：区分接口继承和实现继承

### 条款 35：考虑 virtual 函数以外的其他选择

### 条款 36：绝不重新定义继承而来的 non-virtual 函数

### 条款 37：绝不重新定义继承而来的缺省参数值

### 条款 38：通过复合塑模出 "has-a" 或“根据某物实现出”

### 条款 39：明智而审慎地使用 private 继承

### 条款 40：明智而审慎地使用多重继承



## 7. 模板与泛型编程

### 条款 41：了解隐式接口和编译器多态

### 条款 42：了解 typename 的双重意义

### 条款 43：学习处理模板化基类内的名称

### 条款 44：将与参数无关的代码抽离 template

### 条款 45：运用成员函数模板接受所有兼容类型

### 条款 46：需要类型转换时为模板定义非成员函数

### 条款 47：请使用 traits classes 表现类型信息

### 条款 48：认识 template 元编程





## 8. 定制 new 和 delete

### 条款 49：了解 new-handler 的行为

### 条款 50：了解 new 和 delete 的合理替换实机

### 条款 51：编写 new 和 delete 时需固守常规

### 条款 52：写了 new 就也要写 delete



## 9. 杂项讨论

### 条款 53：不要轻忽编译器的警告

### 条款 54：让自己熟悉包括 TR1在内的标准程序库

### 条款 55：让自己熟悉 Boost
