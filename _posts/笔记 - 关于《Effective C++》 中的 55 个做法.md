---
title: "笔记 - 关于《Effective C++》 中的 55 个做法"
date: 2023-03-19 17:25:00
updated: 2023-03-19 17:25:00
categories:
- 编程语言基础
- Cpp
tags: [Cpp]
---



最近闲来无事，想起了之前买的《Effective C++（第三版）》这本书，就打算看一下。

书中介绍了改善程序与设计的 55 个具体做法，但本文并不会像书中那样对相关问题进行分析，而是直接给出结论和重点（个别也会简单解释）。

如果你在阅读此文章，那么我认为，在大部分场景下，你可以直接采用这些结论，因为不满足这些结论的情况是比较少的。但如果你有时间，还是建议阅读原书，理解这些结论从何而来，以及在哪些情况下可能不适用。

下面的总结顺序，与原书的结构顺序一致，每个做法称为一个“条款”。



## 1. 让自己习惯 C++

### 条款 01：将 C++ 视为一个语言联邦



* **C++ 高效编程守则视状况而变化，取决于你使用 C++ 的哪一部分。**



\-

作者认为 C++ 可以视为一个由相关语言组成的联邦，而非单一语言。在其某个次语言(sublanguage)中，各种守则与通例都倾向简单、直观易懂、并且容易记住。当我们由一个次语言换到另一个次语言的时候，守则可能会改变。这里的守则和通例我理解为一些编程方法、技巧、倾向性（比如两种方案都能实现目标，那么更应当选择哪个方法）等。

作者划分的次语言共有四个：

1. **C part of C++ ** ：即 C++ 仍是以 C 为基础的，这里指的就是采用 C 语言编程的部分。
2. **Object-Oriented C++ ** ：即 C with Classes，包含 class 的各种特性。
3. **Template C++ ** ：C++ 的泛型编程部分。
4. **STL ** ：STL 是个 template 程序库，其有自己特殊的办事方式，当我们使用 STL 时需要遵守它的规约。



记住这四个次语言，当你从某个次语言切换到另一个，可能会导致高效编程守则要求你改变策略。例如对内置（也就是 C-like）类型而言 *pass-by-value* 通常比 *pass-by-reference* 高效，但当你从 C part of C++ 移往 Object-Oriented C++， 由于用户自定义(user-defined)构造函数和析构函数的存在，*pass-by-reference-to-const* 往往更好。运用 Template C++ 时尤其如此，因为彼时你甚至不知道所处理的对象的类型。然而一旦跨入 STL 你就会了解，迭代器和函数对象都是在 C 指针之上塑造出来的，所以对 STL 的选代器和函数对象而言，旧式的 C *pass-by-value* 守则再次适用（参数传递方式的选择细节请见条款 20）。





### 条款 02：尽量以 `const`, `enum`, `inline` 替换 `#define`



* **对于单纯常量，最好以 `const` 对象或 `enum` 替换 `#define`。**
* **对于形似函数的宏(macros)，最好改用 `inline` 函数替换 `#define`。**









### 条款 03：尽可能使用 `const`



* **将某些东西声明为 `const` 可帮助编译器侦测出错误用法。`const` 可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。**
* **编译器强制实施 bitwise constness，但你编写程序时应该使用“概念上的常量性”(conceptual constness) 。**
* **当 `const` 和 `non-const `成员函数有着实质等价的实现时，令 `non-const` 版本调用 `const` 版本可避免代码重复。**





### 条款 04：确定对象被使用前已先被初始化



* **为内置型对象进行手工初始化，因为 C++ 不保证初始化它们。**

* **构造函数最好使用成员初值列(member initialization list)，而不要在构造函数本体内使用赋值操作(assignment)。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。**
* **为免除“跨编译单元之初始化次序”问题，请以 local static 对象替换 non-local static 对象。**



## 2. 构造/析构/赋值运算

### 条款 05：
