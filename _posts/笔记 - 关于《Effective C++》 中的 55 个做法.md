---
title: "笔记 - 关于《Effective C++》 中的 55 个做法"
date: 2023-03-19 17:25:00
updated: 2023-03-19 17:25:00
categories:
- 编程语言基础
- Cpp
tags: [Cpp]
---



最近闲来无事，想起了之前买的《Effective C++（第三版）》这本书，就打算看一下。

书中介绍了改善程序与设计的 55 个具体做法，但本文并不会像书中那样对相关问题进行分析，而是直接给出结论和重点（可能也会简单解释）。

如果你在阅读此文章，那么我认为，在大部分场景下，你可以直接采用这些结论，因为不满足这些结论的情况是比较少的。但如果你有时间，还是建议阅读原书，理解这些结论从何而来，以及在哪些情况下可能不适用。

下面的总结顺序，与原书的结构顺序一致，每个做法称为一个“条款”。



## 1. 让自己习惯 C++

### 条款 01：将 C++ 视为一个语言联邦



* C++ 高效编程守则视状况而变化，取决于你使用 C++ 的哪一部分。











### 条款 02：尽量以 `const`, `enum`, `inline` 替换 `#define`



* 对于单纯常量，最好以 `const` 对象或 `enum` 替换 `#define`。
* 对于形似函数的宏(macros)，最好改用 `inline` 函数替换 `#define`。





### 条款 03：尽可能使用 `const`

* 将某些东西声明为 `const` 可帮助编译器侦测出错误用法。`const` 可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。
* 编译器强制实施 bitwise constness，但你编写程序时应该使用“概念上的常量性”(conceptual constness) 。
* 当 `const` 和 `non-const `成员函数有着实质等价的实现时，令 `non-const` 版本调用 `const` 版本可避免代码重复。



### 条款 04：确定对象被使用前已先被初始化

* 为内置型对象进行手工初始化，因为 C++ 不保证初始化它们。
* 构造函数最好使用成员初值列(member initialization list)，而不要在构造函数本体内使用赋值操作(assignment)。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。
* 为免除“跨编译单元之初始化次序”问题，请以 local static 对象替换 non-local static 对象。



## 2. 构造/析构/赋值运算

### 条款 05：
